---
title: "Circular FIFO Work Queue"
videoId: "0jfDwujUY4Y"
markers:
	"0:00:25": "Owl of Shame: Single producer/Multiple consumer issue"
	"0:03:33": "InterlockedCompareExchange"
	"0:04:20": "Fixing our shame"
	"0:06:19": "Simplifying more with the API change"
	"0:09:00": "Implementing the multithreading API"
	"0:12:42": "Piping the work queue through"
	"0:14:33": "Global defines for AddEntry and CompleteAllWork"
	"0:16:00": "Typedefs for the work queue types"
	"0:18:30": "Smoothing out the multithreading API"
	"0:24:10": "Getting compiling again"
	"0:28:00": "Initializing pointers on game startup"
	"0:28:37": "Continuing clean-up"
	"0:33:00": "GetCurrentThreadID for our test code"
	"0:34:46": "Reviewing/Checking for bugs"
	"0:35:53": "Problem: Queue never resets"
	"0:36:00": "Temporary Fix: Reset queue when all work is done"
	"0:39:04": "Turning the queue into a circular buffer"
	"0:42:50": "Blackboard: Circular FIFO"
	"0:44:15": "Implementing the FIFO queue"
	"0:50:35": "Testing the FIFO queue"
	"0:51:06": "Debugging the FIFO wrapping"
	"0:55:50": "Fixing the completion goal code"
	"0:59:00": "Working multithreaded rendering!"
	"1:02:23": "Q&A"
	"1:02:58": "andsz_ Q: Since the workloads don't complete in order what if one workload takes very long while the other threads wrap around in the queue such that a new workload overwrites the slot with the one that is still running?"
	"1:04:26": "miblo Q: Now that we're multithreaded, could we compile in debug mode and have the game run at a reasonable framerate? (!quote 109)"
	"1:08:27": "powerc9k Q: Can we tell how much faster it is now that it's multithreaded?"
	"1:12:04": "60 FPS test"
	"1:13:03": "robotchocolatedino Q: Instead of asserting that the queue doesn't overflow when adding an entry would it be better to just wait for an entry to be read if there's no space to write"
	"1:13:25": "braincruser Q: Would you call this a thread pool?"
	"1:13:44": "soysaucethekid Q: When stepping through multithreaded code all the other threads stop as well, I take it?"
	"1:15:10": "vellyx Q: Can you make the number of threads an in-game configuration option?"
	"1:15:33": "ttbjm Q: How long until the renderer is sorted?"
	"1:16:10": "pragmascrypt Q: Is the WeShouldSleep still right after you changed the if condition?"
	"1:17:55": "manicthenobody Q: Why do you use #if 0 instead of // or /*?"
	"1:19:09": "nightbasilisk Q: Can you show 4k?"
	"1:19:47": "gasto5  Q: Is multithreaded code less reliable than singlethreaded code?"
	"1:20:37": "noxy_key Q: So is the circular buffer recycling threads after they're done processing a tile? I wasn't clear on why a circular buffer was chosen."
	"1:20:56": "Power cord bumped, computer shut down"
	"1:24:20": "noxy_key Q: (once more) So is the circular buffer recycling threads after they're done processing a tile? I wasn't clear on why a circular buffer was chosen."
	"1:24:35": "Blackboard: Circular buffers"
	"1:26:33": "kyaii Q: I just saw where you're sleeping threads if there's no work, are you still using semaphores to block and wake up threads or are you sleeping threads?"
	"1:27:15": "powerc9k Q: Is the archive going to save this correctly?"
	"1:27:41": "robotchocolatedino Q: Would it be easier to implement the queue as a linked list so it has no maximum size? Since we never need to traverse the list it should still be fast."
	"1:28:56": "robrobby Q: In the rolling buffer you check each entry to be filled before writing a new one in and otherwise skip to the next slot?"
	"1:29:39": "Done for the day."
---

## Quotes

* 109\. Oh my God, dude. That WAS the debug build! (1:04:26)
